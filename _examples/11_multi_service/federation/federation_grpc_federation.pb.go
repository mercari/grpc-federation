// Code generated by protoc-gen-grpc-federation. DO NOT EDIT!
// versions:
//
//	protoc-gen-grpc-federation: dev
//
// source: federation/federation.proto
package federation

import (
	"context"
	"io"
	"log/slog"
	"reflect"

	grpcfed "github.com/mercari/grpc-federation/grpc/federation"
	grpcfedcel "github.com/mercari/grpc-federation/grpc/federation/cel"
	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/trace"

	favorite "example/favorite"
)

var (
	_ = reflect.Invalid // to avoid "imported and not used error"
)

// Federation_GetNameResponseArgument is argument for "federation.GetNameResponse" message.
type FederationService_Federation_GetNameResponseArgument struct {
	Foo *GetNameResponse_Foo
}

// Federation_GetNameResponse_FooArgument is argument for "federation.Foo" message.
type FederationService_Federation_GetNameResponse_FooArgument struct {
}

// Federation_GetPostResponseArgument is argument for "federation.GetPostResponse" message.
type FederationService_Federation_GetPostResponseArgument struct {
	Foo *GetPostResponse_Foo
	Id  string
	P   *Post
}

// Federation_GetPostResponse_FooArgument is argument for "federation.Foo" message.
type FederationService_Federation_GetPostResponse_FooArgument struct {
}

// Federation_PostArgument is argument for "federation.Post" message.
type FederationService_Federation_PostArgument struct {
	Cmp           bool
	FavoriteValue favorite.FavoriteType
	Reaction      *Reaction
	U             *User
}

// Federation_ReactionArgument is argument for "federation.Reaction" message.
type FederationService_Federation_ReactionArgument struct {
	Cmp bool
	V   favorite.FavoriteType
}

// Federation_UserArgument is argument for "federation.User" message.
type FederationService_Federation_UserArgument struct {
	Id   string
	Name string
}

// FederationServiceConfig configuration required to initialize the service that use GRPC Federation.
type FederationServiceConfig struct {
	// ErrorHandler Federation Service often needs to convert errors received from downstream services.
	// If an error occurs during method execution in the Federation Service, this error handler is called and the returned error is treated as a final error.
	ErrorHandler grpcfed.ErrorHandler
	// Logger sets the logger used to output Debug/Info/Error information.
	Logger *slog.Logger
}

// FederationServiceClientFactory provides a factory that creates the gRPC Client needed to invoke methods of the gRPC Service on which the Federation Service depends.
type FederationServiceClientFactory interface {
}

// FederationServiceClientConfig helper to create gRPC client.
// Hints for creating a gRPC Client.
type FederationServiceClientConfig struct {
	// Service FQDN ( `<package-name>.<service-name>` ) of the service on Protocol Buffers.
	Service string
}

// FederationServiceDependentClientSet has a gRPC client for all services on which the federation service depends.
// This is provided as an argument when implementing the custom resolver.
type FederationServiceDependentClientSet struct {
}

// FederationServiceResolver provides an interface to directly implement message resolver and field resolver not defined in Protocol Buffers.
type FederationServiceResolver interface {
}

// FederationServiceCELPluginWasmConfig type alias for grpcfedcel.WasmConfig.
type FederationServiceCELPluginWasmConfig = grpcfedcel.WasmConfig

// FederationServiceCELPluginConfig hints for loading a WebAssembly based plugin.
type FederationServiceCELPluginConfig struct {
}

// FederationServiceEnv keeps the values read from environment variables.
type FederationServiceEnv struct {
	Name       string `envconfig:"NAME" default:"federation"`
	Federation string `envconfig:"FEDERATION"`
}

type keyFederationServiceEnv struct{}

// GetFederationServiceEnv gets environment variables.
func GetFederationServiceEnv(ctx context.Context) *FederationServiceEnv {
	value := ctx.Value(keyFederationServiceEnv{})
	if value == nil {
		return nil
	}
	return value.(*FederationServiceEnv)
}

func withFederationServiceEnv(ctx context.Context, env *FederationServiceEnv) context.Context {
	return context.WithValue(ctx, keyFederationServiceEnv{}, env)
}

// FederationServiceVariable keeps the initial values.
type FederationServiceVariable struct {
	UpperName                 string
	FederationServiceVariable int64
	bool
	FooBarBaz map[string]bool
}

type keyFederationServiceVariable struct{}

// GetFederationServiceVariable gets initial variables.
func GetFederationServiceVariable(ctx context.Context) *FederationServiceVariable {
	value := ctx.Value(keyFederationServiceVariable{})
	if value == nil {
		return nil
	}
	return value.(*FederationServiceVariable)
}

func withFederationServiceVariable(ctx context.Context, svcVar *FederationServiceVariable) context.Context {
	return context.WithValue(ctx, keyFederationServiceVariable{}, svcVar)
}

// FederationServiceUnimplementedResolver a structure implemented to satisfy the Resolver interface.
// An Unimplemented error is always returned.
// This is intended for use when there are many Resolver interfaces that do not need to be implemented,
// by embedding them in a resolver structure that you have created.
type FederationServiceUnimplementedResolver struct{}

// FederationService represents Federation Service.
type FederationService struct {
	UnimplementedFederationServiceServer
	cfg                FederationServiceConfig
	logger             *slog.Logger
	errorHandler       grpcfed.ErrorHandler
	celCacheMap        *grpcfed.CELCacheMap
	tracer             trace.Tracer
	env                *FederationServiceEnv
	svcVar             *FederationServiceVariable
	celTypeHelper      *grpcfed.CELTypeHelper
	celEnvOpts         []grpcfed.CELEnvOption
	celPluginInstances []*grpcfedcel.CELPluginInstance
	client             *FederationServiceDependentClientSet
}

// NewFederationService creates FederationService instance by FederationServiceConfig.
func NewFederationService(cfg FederationServiceConfig) (*FederationService, error) {
	logger := cfg.Logger
	if logger == nil {
		logger = slog.New(slog.NewJSONHandler(io.Discard, nil))
	}
	errorHandler := cfg.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(ctx context.Context, methodName string, err error) error { return err }
	}
	celTypeHelperFieldMap := grpcfed.CELTypeHelperFieldMap{
		"grpc.federation.private.GetNameResponseArgument":     {},
		"grpc.federation.private.GetNameResponse_FooArgument": {},
		"grpc.federation.private.GetPostResponseArgument": {
			"id": grpcfed.NewCELFieldType(grpcfed.CELStringType, "Id"),
		},
		"grpc.federation.private.GetPostResponse_FooArgument": {},
		"grpc.federation.private.PostArgument":                {},
		"grpc.federation.private.ReactionArgument": {
			"v": grpcfed.NewCELFieldType(grpcfed.CELIntType, "V"),
		},
		"grpc.federation.private.UserArgument": {
			"id":   grpcfed.NewCELFieldType(grpcfed.CELStringType, "Id"),
			"name": grpcfed.NewCELFieldType(grpcfed.CELStringType, "Name"),
		},
		"grpc.federation.private.Env": {
			"name":       grpcfed.NewCELFieldType(grpcfed.CELStringType, "Name"),
			"federation": grpcfed.NewCELFieldType(grpcfed.CELStringType, "Federation"),
		},
		"grpc.federation.private.ServiceVariable": {
			"upper_name":                  grpcfed.NewCELFieldType(grpcfed.CELStringType, "UpperName"),
			"federation_service_variable": grpcfed.NewCELFieldType(grpcfed.CELIntType, "FederationServiceVariable"),
			"":                            grpcfed.NewCELFieldType(grpcfed.CELBoolType, ""),
			"foo_bar_baz":                 grpcfed.NewCELFieldType(grpcfed.NewCELMapType(grpcfed.CELStringType, grpcfed.CELBoolType), "FooBarBaz"),
		},
	}
	celTypeHelper := grpcfed.NewCELTypeHelper("federation", celTypeHelperFieldMap)
	var celEnvOpts []grpcfed.CELEnvOption
	celEnvOpts = append(celEnvOpts, grpcfed.NewDefaultEnvOptions(celTypeHelper)...)
	celEnvOpts = append(celEnvOpts, grpcfed.EnumAccessorOptions("favorite.FavoriteType", favorite.FavoriteType_value, favorite.FavoriteType_name)...)
	celEnvOpts = append(celEnvOpts, grpcfed.EnumAccessorOptions("federation.MyFavoriteType", MyFavoriteType_value, MyFavoriteType_name)...)
	celEnvOpts = append(celEnvOpts, grpcfed.NewCELVariable("grpc.federation.env", grpcfed.CELObjectType("grpc.federation.private.Env")))
	celEnvOpts = append(celEnvOpts, grpcfed.NewCELVariable("grpc.federation.var", grpcfed.CELObjectType("grpc.federation.private.ServiceVariable")))
	var env FederationServiceEnv
	if err := grpcfed.LoadEnv("", &env); err != nil {
		return nil, err
	}
	svc := &FederationService{
		cfg:           cfg,
		logger:        logger,
		errorHandler:  errorHandler,
		celEnvOpts:    celEnvOpts,
		celTypeHelper: celTypeHelper,
		celCacheMap:   grpcfed.NewCELCacheMap(),
		tracer:        otel.Tracer("federation.FederationService"),
		env:           &env,
		svcVar:        new(FederationServiceVariable),
		client:        &FederationServiceDependentClientSet{},
	}
	if err := svc.initServiceVariables(); err != nil {
		return nil, err
	}
	return svc, nil
}

// CleanupFederationService cleanup all resources to prevent goroutine leaks.
func CleanupFederationService(ctx context.Context, svc *FederationService) {
	svc.cleanup(ctx)
}

func (s *FederationService) cleanup(ctx context.Context) {
	for _, instance := range s.celPluginInstances {
		instance.Close(ctx)
	}
}
func (s *FederationService) initServiceVariables() error {
	ctx := grpcfed.WithCELCacheMap(grpcfed.WithLogger(context.Background(), s.logger), s.celCacheMap)
	type localValueType struct {
		*grpcfed.LocalValue
		vars *FederationServiceVariable
	}
	value := &localValueType{
		LocalValue: grpcfed.NewServiceVariableLocalValue(s.celEnvOpts),
		vars:       s.svcVar,
	}
	value.AddEnv(s.env)
	value.AddServiceVariable(s.svcVar)

	/*
		def {
		  name: "upper_name"
		  by: "grpc.federation.strings.toUpper(grpc.federation.env.name)"
		}
	*/
	def_upper_name := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[string, *localValueType]{
			Name: `upper_name`,
			Type: grpcfed.CELStringType,
			Setter: func(value *localValueType, v string) error {
				value.vars.UpperName = v
				return nil
			},
			By:           `grpc.federation.strings.toUpper(grpc.federation.env.name)`,
			ByCacheIndex: 1,
		})
	}
	if err := def_upper_name(ctx); err != nil {
		return err
	}

	/*
		def {
		  name: "federation_service_variable"
		  by: "1"
		}
	*/
	def_federation_service_variable := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[int64, *localValueType]{
			Name: `federation_service_variable`,
			Type: grpcfed.CELIntType,
			Setter: func(value *localValueType, v int64) error {
				value.vars.FederationServiceVariable = v
				return nil
			},
			By:           `1`,
			ByCacheIndex: 2,
		})
	}
	if err := def_federation_service_variable(ctx); err != nil {
		return err
	}

	if err := grpcfed.If(ctx, &grpcfed.IfParam[*localValueType]{
		Value:      value,
		Expr:       `grpc.federation.env.name == ''`,
		CacheIndex: 3,
		Body: func(value *localValueType) error {
			errmsg, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
				Value:      value,
				Expr:       `'name environment variable is unspecified'`,
				OutType:    reflect.TypeOf(""),
				CacheIndex: 4,
			})
			if err != nil {
				return err
			}
			return grpcfed.NewGRPCStatus(grpcfed.InternalCode, errmsg.(string)).Err()
		},
	}); err != nil {
		return err
	}

	/*
		def {
		  name: "foo_bar_baz"
		  by: "{'a': true}"
		}
	*/
	def_foo_bar_baz := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[map[string]bool, *localValueType]{
			Name: `foo_bar_baz`,
			Type: grpcfed.NewCELMapType(grpcfed.CELStringType, grpcfed.CELBoolType),
			Setter: func(value *localValueType, v map[string]bool) error {
				value.vars.FooBarBaz = v
				return nil
			},
			By:           `{'a': true}`,
			ByCacheIndex: 5,
		})
	}
	if err := def_foo_bar_baz(ctx); err != nil {
		return err
	}

	return nil
}

// GetPost implements "federation.FederationService/GetPost" method.
func (s *FederationService) GetPost(ctx context.Context, req *GetPostRequest) (res *GetPostResponse, e error) {
	ctx, span := s.tracer.Start(ctx, "federation.FederationService/GetPost")
	defer span.End()
	ctx = withFederationServiceEnv(ctx, s.env)
	ctx = withFederationServiceVariable(ctx, s.svcVar)
	ctx = grpcfed.WithLogger(ctx, s.logger)
	ctx = grpcfed.WithCELCacheMap(ctx, s.celCacheMap)
	defer func() {
		if r := recover(); r != nil {
			e = grpcfed.RecoverError(r, grpcfed.StackTrace())
			grpcfed.OutputErrorLog(ctx, e)
		}
	}()
	res, err := s.resolve_Federation_GetPostResponse(ctx, &FederationService_Federation_GetPostResponseArgument{
		Id: req.GetId(),
	})
	if err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		grpcfed.OutputErrorLog(ctx, err)
		return nil, err
	}
	return res, nil
}

// GetName implements "federation.FederationService/GetName" method.
func (s *FederationService) GetName(ctx context.Context, req *GetNameRequest) (res *GetNameResponse, e error) {
	ctx, span := s.tracer.Start(ctx, "federation.FederationService/GetName")
	defer span.End()
	ctx = withFederationServiceEnv(ctx, s.env)
	ctx = withFederationServiceVariable(ctx, s.svcVar)
	ctx = grpcfed.WithLogger(ctx, s.logger)
	ctx = grpcfed.WithCELCacheMap(ctx, s.celCacheMap)
	defer func() {
		if r := recover(); r != nil {
			e = grpcfed.RecoverError(r, grpcfed.StackTrace())
			grpcfed.OutputErrorLog(ctx, e)
		}
	}()
	res, err := s.resolve_Federation_GetNameResponse(ctx, &FederationService_Federation_GetNameResponseArgument{})
	if err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		grpcfed.OutputErrorLog(ctx, err)
		return nil, err
	}
	return res, nil
}

// resolve_Federation_GetNameResponse resolve "federation.GetNameResponse" message.
func (s *FederationService) resolve_Federation_GetNameResponse(ctx context.Context, req *FederationService_Federation_GetNameResponseArgument) (*GetNameResponse, error) {
	ctx, span := s.tracer.Start(ctx, "federation.GetNameResponse")
	defer span.End()
	ctx = grpcfed.WithLogger(ctx, grpcfed.Logger(ctx), grpcfed.LogAttrs(ctx)...)

	grpcfed.Logger(ctx).DebugContext(ctx, "resolve federation.GetNameResponse", slog.Any("message_args", s.logvalue_Federation_GetNameResponseArgument(req)))
	type localValueType struct {
		*grpcfed.LocalValue
		vars struct {
			Foo *GetNameResponse_Foo
		}
	}
	value := &localValueType{LocalValue: grpcfed.NewLocalValue(ctx, s.celEnvOpts, "grpc.federation.private.GetNameResponseArgument", req)}
	value.AddEnv(s.env)
	value.AddServiceVariable(s.svcVar)
	/*
		def {
		  name: "foo"
		  message {
		    name: "Foo"
		  }
		}
	*/
	def_foo := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[*GetNameResponse_Foo, *localValueType]{
			Name: `foo`,
			Type: grpcfed.CELObjectType("federation.GetNameResponse.Foo"),
			Setter: func(value *localValueType, v *GetNameResponse_Foo) error {
				value.vars.Foo = v
				return nil
			},
			Message: func(ctx context.Context, value *localValueType) (any, error) {
				args := &FederationService_Federation_GetNameResponse_FooArgument{}
				ret, err := s.resolve_Federation_GetNameResponse_Foo(ctx, args)
				if err != nil {
					return nil, err
				}
				return ret, nil
			},
		})
	}

	if err := def_foo(ctx); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}

	// assign named parameters to message arguments to pass to the custom resolver.
	req.Foo = value.vars.Foo

	// create a message value to be returned.
	ret := &GetNameResponse{}

	// field binding section.
	// (grpc.federation.field).by = "grpc.federation.env.name"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
		Value:      value,
		Expr:       `grpc.federation.env.name`,
		CacheIndex: 6,
		Setter: func(v string) error {
			ret.Name = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "foo"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[*GetNameResponse_Foo]{
		Value:      value,
		Expr:       `foo`,
		CacheIndex: 7,
		Setter: func(v *GetNameResponse_Foo) error {
			ret.Foo = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}

	grpcfed.Logger(ctx).DebugContext(ctx, "resolved federation.GetNameResponse", slog.Any("federation.GetNameResponse", s.logvalue_Federation_GetNameResponse(ret)))
	return ret, nil
}

// resolve_Federation_GetNameResponse_Foo resolve "federation.GetNameResponse.Foo" message.
func (s *FederationService) resolve_Federation_GetNameResponse_Foo(ctx context.Context, req *FederationService_Federation_GetNameResponse_FooArgument) (*GetNameResponse_Foo, error) {
	ctx, span := s.tracer.Start(ctx, "federation.GetNameResponse.Foo")
	defer span.End()
	ctx = grpcfed.WithLogger(ctx, grpcfed.Logger(ctx), grpcfed.LogAttrs(ctx)...)

	grpcfed.Logger(ctx).DebugContext(ctx, "resolve federation.GetNameResponse.Foo", slog.Any("message_args", s.logvalue_Federation_GetNameResponse_FooArgument(req)))
	type localValueType struct {
		*grpcfed.LocalValue
		vars struct {
		}
	}
	value := &localValueType{LocalValue: grpcfed.NewLocalValue(ctx, s.celEnvOpts, "grpc.federation.private.GetNameResponse_FooArgument", req)}
	value.AddEnv(s.env)
	value.AddServiceVariable(s.svcVar)

	// create a message value to be returned.
	ret := &GetNameResponse_Foo{}

	// field binding section.
	// (grpc.federation.field).by = "'y'"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
		Value:      value,
		Expr:       `'y'`,
		CacheIndex: 8,
		Setter: func(v string) error {
			ret.Y = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}

	grpcfed.Logger(ctx).DebugContext(ctx, "resolved federation.GetNameResponse.Foo", slog.Any("federation.GetNameResponse.Foo", s.logvalue_Federation_GetNameResponse_Foo(ret)))
	return ret, nil
}

// resolve_Federation_GetPostResponse resolve "federation.GetPostResponse" message.
func (s *FederationService) resolve_Federation_GetPostResponse(ctx context.Context, req *FederationService_Federation_GetPostResponseArgument) (*GetPostResponse, error) {
	ctx, span := s.tracer.Start(ctx, "federation.GetPostResponse")
	defer span.End()
	ctx = grpcfed.WithLogger(ctx, grpcfed.Logger(ctx), grpcfed.LogAttrs(ctx)...)

	grpcfed.Logger(ctx).DebugContext(ctx, "resolve federation.GetPostResponse", slog.Any("message_args", s.logvalue_Federation_GetPostResponseArgument(req)))
	type localValueType struct {
		*grpcfed.LocalValue
		vars struct {
			Foo *GetPostResponse_Foo
			P   *Post
		}
	}
	value := &localValueType{LocalValue: grpcfed.NewLocalValue(ctx, s.celEnvOpts, "grpc.federation.private.GetPostResponseArgument", req)}
	value.AddEnv(s.env)
	value.AddServiceVariable(s.svcVar)
	/*
		def {
		  name: "p"
		  message {
		    name: "Post"
		  }
		}
	*/
	def_p := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[*Post, *localValueType]{
			Name: `p`,
			Type: grpcfed.CELObjectType("federation.Post"),
			Setter: func(value *localValueType, v *Post) error {
				value.vars.P = v
				return nil
			},
			Message: func(ctx context.Context, value *localValueType) (any, error) {
				args := &FederationService_Federation_PostArgument{}
				ret, err := s.resolve_Federation_Post(ctx, args)
				if err != nil {
					return nil, err
				}
				return ret, nil
			},
		})
	}

	/*
		def {
		  name: "foo"
		  message {
		    name: "Foo"
		  }
		}
	*/
	def_foo := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[*GetPostResponse_Foo, *localValueType]{
			Name: `foo`,
			Type: grpcfed.CELObjectType("federation.GetPostResponse.Foo"),
			Setter: func(value *localValueType, v *GetPostResponse_Foo) error {
				value.vars.Foo = v
				return nil
			},
			Message: func(ctx context.Context, value *localValueType) (any, error) {
				args := &FederationService_Federation_GetPostResponse_FooArgument{}
				ret, err := s.resolve_Federation_GetPostResponse_Foo(ctx, args)
				if err != nil {
					return nil, err
				}
				return ret, nil
			},
		})
	}

	// A tree view of message dependencies is shown below.
	/*
	   foo ─┐
	     p ─┤
	*/
	eg, ctx1 := grpcfed.ErrorGroupWithContext(ctx)

	grpcfed.GoWithRecover(eg, func() (any, error) {
		if err := def_foo(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		return nil, nil
	})

	grpcfed.GoWithRecover(eg, func() (any, error) {
		if err := def_p(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		return nil, nil
	})

	if err := eg.Wait(); err != nil {
		return nil, err
	}

	// assign named parameters to message arguments to pass to the custom resolver.
	req.Foo = value.vars.Foo
	req.P = value.vars.P

	// create a message value to be returned.
	ret := &GetPostResponse{}

	// field binding section.
	// (grpc.federation.field).by = "p"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[*Post]{
		Value:      value,
		Expr:       `p`,
		CacheIndex: 9,
		Setter: func(v *Post) error {
			ret.Post = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "grpc.federation.var.upper_name"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
		Value:      value,
		Expr:       `grpc.federation.var.upper_name`,
		CacheIndex: 10,
		Setter: func(v string) error {
			ret.UpperName = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "foo"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[*GetPostResponse_Foo]{
		Value:      value,
		Expr:       `foo`,
		CacheIndex: 11,
		Setter: func(v *GetPostResponse_Foo) error {
			ret.Foo = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}

	grpcfed.Logger(ctx).DebugContext(ctx, "resolved federation.GetPostResponse", slog.Any("federation.GetPostResponse", s.logvalue_Federation_GetPostResponse(ret)))
	return ret, nil
}

// resolve_Federation_GetPostResponse_Foo resolve "federation.GetPostResponse.Foo" message.
func (s *FederationService) resolve_Federation_GetPostResponse_Foo(ctx context.Context, req *FederationService_Federation_GetPostResponse_FooArgument) (*GetPostResponse_Foo, error) {
	ctx, span := s.tracer.Start(ctx, "federation.GetPostResponse.Foo")
	defer span.End()
	ctx = grpcfed.WithLogger(ctx, grpcfed.Logger(ctx), grpcfed.LogAttrs(ctx)...)

	grpcfed.Logger(ctx).DebugContext(ctx, "resolve federation.GetPostResponse.Foo", slog.Any("message_args", s.logvalue_Federation_GetPostResponse_FooArgument(req)))
	type localValueType struct {
		*grpcfed.LocalValue
		vars struct {
		}
	}
	value := &localValueType{LocalValue: grpcfed.NewLocalValue(ctx, s.celEnvOpts, "grpc.federation.private.GetPostResponse_FooArgument", req)}
	value.AddEnv(s.env)
	value.AddServiceVariable(s.svcVar)

	// create a message value to be returned.
	ret := &GetPostResponse_Foo{}

	// field binding section.
	// (grpc.federation.field).by = "'x'"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
		Value:      value,
		Expr:       `'x'`,
		CacheIndex: 12,
		Setter: func(v string) error {
			ret.X = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}

	grpcfed.Logger(ctx).DebugContext(ctx, "resolved federation.GetPostResponse.Foo", slog.Any("federation.GetPostResponse.Foo", s.logvalue_Federation_GetPostResponse_Foo(ret)))
	return ret, nil
}

// resolve_Federation_Post resolve "federation.Post" message.
func (s *FederationService) resolve_Federation_Post(ctx context.Context, req *FederationService_Federation_PostArgument) (*Post, error) {
	ctx, span := s.tracer.Start(ctx, "federation.Post")
	defer span.End()
	ctx = grpcfed.WithLogger(ctx, grpcfed.Logger(ctx), grpcfed.LogAttrs(ctx)...)

	grpcfed.Logger(ctx).DebugContext(ctx, "resolve federation.Post", slog.Any("message_args", s.logvalue_Federation_PostArgument(req)))
	type localValueType struct {
		*grpcfed.LocalValue
		vars struct {
			Cmp           bool
			FavoriteValue favorite.FavoriteType
			Reaction      *Reaction
			U             *User
		}
	}
	value := &localValueType{LocalValue: grpcfed.NewLocalValue(ctx, s.celEnvOpts, "grpc.federation.private.PostArgument", req)}
	value.AddEnv(s.env)
	value.AddServiceVariable(s.svcVar)
	/*
		def {
		  name: "u"
		  message {
		    name: "User"
		    args: [
		      { name: "id", by: "'foo'" },
		      { name: "name", by: "'bar'" }
		    ]
		  }
		}
	*/
	def_u := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[*User, *localValueType]{
			Name: `u`,
			Type: grpcfed.CELObjectType("federation.User"),
			Setter: func(value *localValueType, v *User) error {
				value.vars.U = v
				return nil
			},
			Message: func(ctx context.Context, value *localValueType) (any, error) {
				args := &FederationService_Federation_UserArgument{}
				// { name: "id", by: "'foo'" }
				if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
					Value:      value,
					Expr:       `'foo'`,
					CacheIndex: 13,
					Setter: func(v string) error {
						args.Id = v
						return nil
					},
				}); err != nil {
					return nil, err
				}
				// { name: "name", by: "'bar'" }
				if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
					Value:      value,
					Expr:       `'bar'`,
					CacheIndex: 14,
					Setter: func(v string) error {
						args.Name = v
						return nil
					},
				}); err != nil {
					return nil, err
				}
				ret, err := s.resolve_Federation_User(ctx, args)
				if err != nil {
					return nil, err
				}
				return ret, nil
			},
		})
	}

	/*
		def {
		  name: "favorite_value"
		  by: "favorite.FavoriteType.value('TYPE1')"
		}
	*/
	def_favorite_value := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[favorite.FavoriteType, *localValueType]{
			Name: `favorite_value`,
			Type: grpcfed.CELIntType,
			Setter: func(value *localValueType, v favorite.FavoriteType) error {
				value.vars.FavoriteValue = v
				return nil
			},
			By:           `favorite.FavoriteType.value('TYPE1')`,
			ByCacheIndex: 15,
		})
	}

	/*
		def {
		  name: "cmp"
		  by: "favorite_value == favorite.FavoriteType.TYPE1"
		}
	*/
	def_cmp := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[bool, *localValueType]{
			Name: `cmp`,
			Type: grpcfed.CELBoolType,
			Setter: func(value *localValueType, v bool) error {
				value.vars.Cmp = v
				return nil
			},
			By:           `favorite_value == favorite.FavoriteType.TYPE1`,
			ByCacheIndex: 16,
		})
	}

	/*
		def {
		  name: "reaction"
		  message {
		    name: "Reaction"
		    args { name: "v", by: "favorite_value" }
		  }
		}
	*/
	def_reaction := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[*Reaction, *localValueType]{
			Name: `reaction`,
			Type: grpcfed.CELObjectType("federation.Reaction"),
			Setter: func(value *localValueType, v *Reaction) error {
				value.vars.Reaction = v
				return nil
			},
			Message: func(ctx context.Context, value *localValueType) (any, error) {
				args := &FederationService_Federation_ReactionArgument{}
				// { name: "v", by: "favorite_value" }
				if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[favorite.FavoriteType]{
					Value:      value,
					Expr:       `favorite_value`,
					CacheIndex: 17,
					Setter: func(v favorite.FavoriteType) error {
						args.V = v
						return nil
					},
				}); err != nil {
					return nil, err
				}
				ret, err := s.resolve_Federation_Reaction(ctx, args)
				if err != nil {
					return nil, err
				}
				return ret, nil
			},
		})
	}

	// A tree view of message dependencies is shown below.
	/*
	   favorite_value ─┐
	                        cmp ─┐
	   favorite_value ─┐         │
	                   reaction ─┤
	                          u ─┤
	*/
	eg, ctx1 := grpcfed.ErrorGroupWithContext(ctx)

	grpcfed.GoWithRecover(eg, func() (any, error) {
		if err := def_favorite_value(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		if err := def_cmp(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		return nil, nil
	})

	grpcfed.GoWithRecover(eg, func() (any, error) {
		if err := def_favorite_value(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		if err := def_reaction(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		return nil, nil
	})

	grpcfed.GoWithRecover(eg, func() (any, error) {
		if err := def_u(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		return nil, nil
	})

	if err := eg.Wait(); err != nil {
		return nil, err
	}

	// assign named parameters to message arguments to pass to the custom resolver.
	req.Cmp = value.vars.Cmp
	req.FavoriteValue = value.vars.FavoriteValue
	req.Reaction = value.vars.Reaction
	req.U = value.vars.U

	// create a message value to be returned.
	ret := &Post{}

	// field binding section.
	// (grpc.federation.field).by = "'post-id'"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
		Value:      value,
		Expr:       `'post-id'`,
		CacheIndex: 18,
		Setter: func(v string) error {
			ret.Id = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "'title'"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
		Value:      value,
		Expr:       `'title'`,
		CacheIndex: 19,
		Setter: func(v string) error {
			ret.Title = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "'content'"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
		Value:      value,
		Expr:       `'content'`,
		CacheIndex: 20,
		Setter: func(v string) error {
			ret.Content = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "u"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[*User]{
		Value:      value,
		Expr:       `u`,
		CacheIndex: 21,
		Setter: func(v *User) error {
			ret.User = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "reaction"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[*Reaction]{
		Value:      value,
		Expr:       `reaction`,
		CacheIndex: 22,
		Setter: func(v *Reaction) error {
			ret.Reaction = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "favorite_value"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[favorite.FavoriteType]{
		Value:      value,
		Expr:       `favorite_value`,
		CacheIndex: 23,
		Setter: func(v favorite.FavoriteType) error {
			favoriteValueValue, err := s.cast_Favorite_FavoriteType__to__Federation_MyFavoriteType(v)
			if err != nil {
				return err
			}
			ret.FavoriteValue = favoriteValueValue
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "cmp"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[bool]{
		Value:      value,
		Expr:       `cmp`,
		CacheIndex: 24,
		Setter: func(v bool) error {
			ret.Cmp = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}

	grpcfed.Logger(ctx).DebugContext(ctx, "resolved federation.Post", slog.Any("federation.Post", s.logvalue_Federation_Post(ret)))
	return ret, nil
}

// resolve_Federation_Reaction resolve "federation.Reaction" message.
func (s *FederationService) resolve_Federation_Reaction(ctx context.Context, req *FederationService_Federation_ReactionArgument) (*Reaction, error) {
	ctx, span := s.tracer.Start(ctx, "federation.Reaction")
	defer span.End()
	ctx = grpcfed.WithLogger(ctx, grpcfed.Logger(ctx), grpcfed.LogAttrs(ctx)...)

	grpcfed.Logger(ctx).DebugContext(ctx, "resolve federation.Reaction", slog.Any("message_args", s.logvalue_Federation_ReactionArgument(req)))
	type localValueType struct {
		*grpcfed.LocalValue
		vars struct {
			Cmp bool
		}
	}
	value := &localValueType{LocalValue: grpcfed.NewLocalValue(ctx, s.celEnvOpts, "grpc.federation.private.ReactionArgument", req)}
	value.AddEnv(s.env)
	value.AddServiceVariable(s.svcVar)
	/*
		def {
		  name: "cmp"
		  by: "$.v == favorite.FavoriteType.TYPE1"
		}
	*/
	def_cmp := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[bool, *localValueType]{
			Name: `cmp`,
			Type: grpcfed.CELBoolType,
			Setter: func(value *localValueType, v bool) error {
				value.vars.Cmp = v
				return nil
			},
			By:           `$.v == favorite.FavoriteType.TYPE1`,
			ByCacheIndex: 25,
		})
	}

	if err := def_cmp(ctx); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}

	// assign named parameters to message arguments to pass to the custom resolver.
	req.Cmp = value.vars.Cmp

	// create a message value to be returned.
	ret := &Reaction{}

	// field binding section.
	// (grpc.federation.field).by = "favorite.FavoriteType.value('TYPE1')"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[favorite.FavoriteType]{
		Value:      value,
		Expr:       `favorite.FavoriteType.value('TYPE1')`,
		CacheIndex: 26,
		Setter: func(v favorite.FavoriteType) error {
			ret.FavoriteType = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "favorite.FavoriteType.name(favorite.FavoriteType.value('TYPE1'))"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
		Value:      value,
		Expr:       `favorite.FavoriteType.name(favorite.FavoriteType.value('TYPE1'))`,
		CacheIndex: 27,
		Setter: func(v string) error {
			ret.FavoriteTypeStr = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "cmp"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[bool]{
		Value:      value,
		Expr:       `cmp`,
		CacheIndex: 28,
		Setter: func(v bool) error {
			ret.Cmp = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}

	grpcfed.Logger(ctx).DebugContext(ctx, "resolved federation.Reaction", slog.Any("federation.Reaction", s.logvalue_Federation_Reaction(ret)))
	return ret, nil
}

// resolve_Federation_User resolve "federation.User" message.
func (s *FederationService) resolve_Federation_User(ctx context.Context, req *FederationService_Federation_UserArgument) (*User, error) {
	ctx, span := s.tracer.Start(ctx, "federation.User")
	defer span.End()
	ctx = grpcfed.WithLogger(ctx, grpcfed.Logger(ctx), grpcfed.LogAttrs(ctx)...)

	grpcfed.Logger(ctx).DebugContext(ctx, "resolve federation.User", slog.Any("message_args", s.logvalue_Federation_UserArgument(req)))
	type localValueType struct {
		*grpcfed.LocalValue
		vars struct {
		}
	}
	value := &localValueType{LocalValue: grpcfed.NewLocalValue(ctx, s.celEnvOpts, "grpc.federation.private.UserArgument", req)}
	value.AddEnv(s.env)
	value.AddServiceVariable(s.svcVar)

	// create a message value to be returned.
	ret := &User{}

	// field binding section.
	// (grpc.federation.field).by = "$.id"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
		Value:      value,
		Expr:       `$.id`,
		CacheIndex: 29,
		Setter: func(v string) error {
			ret.Id = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "$.name"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
		Value:      value,
		Expr:       `$.name`,
		CacheIndex: 30,
		Setter: func(v string) error {
			ret.Name = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}

	grpcfed.Logger(ctx).DebugContext(ctx, "resolved federation.User", slog.Any("federation.User", s.logvalue_Federation_User(ret)))
	return ret, nil
}

// cast_Favorite_FavoriteType__to__Federation_MyFavoriteType cast from "favorite.FavoriteType" to "federation.MyFavoriteType".
func (s *FederationService) cast_Favorite_FavoriteType__to__Federation_MyFavoriteType(from favorite.FavoriteType) (MyFavoriteType, error) {
	var ret MyFavoriteType
	switch from {
	case favorite.FavoriteType_UNKNOWN:
		ret = MyFavoriteType_UNKNOWN
	case favorite.FavoriteType_TYPE1:
		ret = MyFavoriteType_TYPE1
	default:
		ret = 0
	}
	return ret, nil
}

func (s *FederationService) logvalue_Favorite_FavoriteType(v favorite.FavoriteType) slog.Value {
	switch v {
	case favorite.FavoriteType_UNKNOWN:
		return slog.StringValue("UNKNOWN")
	case favorite.FavoriteType_TYPE1:
		return slog.StringValue("TYPE1")
	case favorite.FavoriteType_TYPE2:
		return slog.StringValue("TYPE2")
	}
	return slog.StringValue("")
}

func (s *FederationService) logvalue_Federation_GetNameResponse(v *GetNameResponse) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("name", v.GetName()),
		slog.Any("foo", s.logvalue_Federation_GetNameResponse_Foo(v.GetFoo())),
	)
}

func (s *FederationService) logvalue_Federation_GetNameResponseArgument(v *FederationService_Federation_GetNameResponseArgument) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue()
}

func (s *FederationService) logvalue_Federation_GetNameResponse_Foo(v *GetNameResponse_Foo) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("y", v.GetY()),
	)
}

func (s *FederationService) logvalue_Federation_GetNameResponse_FooArgument(v *FederationService_Federation_GetNameResponse_FooArgument) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue()
}

func (s *FederationService) logvalue_Federation_GetPostResponse(v *GetPostResponse) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.Any("post", s.logvalue_Federation_Post(v.GetPost())),
		slog.String("upper_name", v.GetUpperName()),
		slog.Any("foo", s.logvalue_Federation_GetPostResponse_Foo(v.GetFoo())),
	)
}

func (s *FederationService) logvalue_Federation_GetPostResponseArgument(v *FederationService_Federation_GetPostResponseArgument) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("id", v.Id),
	)
}

func (s *FederationService) logvalue_Federation_GetPostResponse_Foo(v *GetPostResponse_Foo) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("x", v.GetX()),
	)
}

func (s *FederationService) logvalue_Federation_GetPostResponse_FooArgument(v *FederationService_Federation_GetPostResponse_FooArgument) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue()
}

func (s *FederationService) logvalue_Federation_MyFavoriteType(v MyFavoriteType) slog.Value {
	switch v {
	case MyFavoriteType_UNKNOWN:
		return slog.StringValue("UNKNOWN")
	case MyFavoriteType_TYPE1:
		return slog.StringValue("TYPE1")
	}
	return slog.StringValue("")
}

func (s *FederationService) logvalue_Federation_Post(v *Post) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("id", v.GetId()),
		slog.String("title", v.GetTitle()),
		slog.String("content", v.GetContent()),
		slog.Any("user", s.logvalue_Federation_User(v.GetUser())),
		slog.Any("reaction", s.logvalue_Federation_Reaction(v.GetReaction())),
		slog.String("favorite_value", s.logvalue_Federation_MyFavoriteType(v.GetFavoriteValue()).String()),
		slog.Bool("cmp", v.GetCmp()),
	)
}

func (s *FederationService) logvalue_Federation_PostArgument(v *FederationService_Federation_PostArgument) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue()
}

func (s *FederationService) logvalue_Federation_Reaction(v *Reaction) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("favorite_type", s.logvalue_Favorite_FavoriteType(v.GetFavoriteType()).String()),
		slog.String("favorite_type_str", v.GetFavoriteTypeStr()),
		slog.Bool("cmp", v.GetCmp()),
	)
}

func (s *FederationService) logvalue_Federation_ReactionArgument(v *FederationService_Federation_ReactionArgument) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("v", s.logvalue_Favorite_FavoriteType(v.V).String()),
	)
}

func (s *FederationService) logvalue_Federation_User(v *User) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("id", v.GetId()),
		slog.String("name", v.GetName()),
	)
}

func (s *FederationService) logvalue_Federation_UserArgument(v *FederationService_Federation_UserArgument) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("id", v.Id),
		slog.String("name", v.Name),
	)
}

// Federation_GetNameResponseArgument is argument for "federation.GetNameResponse" message.
type PrivateService_Federation_GetNameResponseArgument struct {
	Foo *GetNameResponse_Foo
}

// Federation_GetNameResponse_FooArgument is argument for "federation.Foo" message.
type PrivateService_Federation_GetNameResponse_FooArgument struct {
}

// Federation_GetPostResponseArgument is argument for "federation.GetPostResponse" message.
type PrivateService_Federation_GetPostResponseArgument struct {
	Foo *GetPostResponse_Foo
	Id  string
	P   *Post
}

// Federation_GetPostResponse_FooArgument is argument for "federation.Foo" message.
type PrivateService_Federation_GetPostResponse_FooArgument struct {
}

// Federation_PostArgument is argument for "federation.Post" message.
type PrivateService_Federation_PostArgument struct {
	Cmp           bool
	FavoriteValue favorite.FavoriteType
	Reaction      *Reaction
	U             *User
}

// Federation_ReactionArgument is argument for "federation.Reaction" message.
type PrivateService_Federation_ReactionArgument struct {
	Cmp bool
	V   favorite.FavoriteType
}

// Federation_UserArgument is argument for "federation.User" message.
type PrivateService_Federation_UserArgument struct {
	Id   string
	Name string
}

// PrivateServiceConfig configuration required to initialize the service that use GRPC Federation.
type PrivateServiceConfig struct {
	// ErrorHandler Federation Service often needs to convert errors received from downstream services.
	// If an error occurs during method execution in the Federation Service, this error handler is called and the returned error is treated as a final error.
	ErrorHandler grpcfed.ErrorHandler
	// Logger sets the logger used to output Debug/Info/Error information.
	Logger *slog.Logger
}

// PrivateServiceClientFactory provides a factory that creates the gRPC Client needed to invoke methods of the gRPC Service on which the Federation Service depends.
type PrivateServiceClientFactory interface {
}

// PrivateServiceClientConfig helper to create gRPC client.
// Hints for creating a gRPC Client.
type PrivateServiceClientConfig struct {
	// Service FQDN ( `<package-name>.<service-name>` ) of the service on Protocol Buffers.
	Service string
}

// PrivateServiceDependentClientSet has a gRPC client for all services on which the federation service depends.
// This is provided as an argument when implementing the custom resolver.
type PrivateServiceDependentClientSet struct {
}

// PrivateServiceResolver provides an interface to directly implement message resolver and field resolver not defined in Protocol Buffers.
type PrivateServiceResolver interface {
}

// PrivateServiceCELPluginWasmConfig type alias for grpcfedcel.WasmConfig.
type PrivateServiceCELPluginWasmConfig = grpcfedcel.WasmConfig

// PrivateServiceCELPluginConfig hints for loading a WebAssembly based plugin.
type PrivateServiceCELPluginConfig struct {
}

// PrivateServiceEnv keeps the values read from environment variables.
type PrivateServiceEnv struct {
	Name    string `envconfig:"NAME" default:"private"`
	Private string `envconfig:"PRIVATE"`
}

type keyPrivateServiceEnv struct{}

// GetPrivateServiceEnv gets environment variables.
func GetPrivateServiceEnv(ctx context.Context) *PrivateServiceEnv {
	value := ctx.Value(keyPrivateServiceEnv{})
	if value == nil {
		return nil
	}
	return value.(*PrivateServiceEnv)
}

func withPrivateServiceEnv(ctx context.Context, env *PrivateServiceEnv) context.Context {
	return context.WithValue(ctx, keyPrivateServiceEnv{}, env)
}

// PrivateServiceVariable keeps the initial values.
type PrivateServiceVariable struct {
	UpperName               string
	PrivateServiceEnum      MyFavoriteType
	PrivateServiceUser      *User
	Users                   []*User
	PrivateServiceUserNames []string
	FooBarBaz               map[string]bool
}

type keyPrivateServiceVariable struct{}

// GetPrivateServiceVariable gets initial variables.
func GetPrivateServiceVariable(ctx context.Context) *PrivateServiceVariable {
	value := ctx.Value(keyPrivateServiceVariable{})
	if value == nil {
		return nil
	}
	return value.(*PrivateServiceVariable)
}

func withPrivateServiceVariable(ctx context.Context, svcVar *PrivateServiceVariable) context.Context {
	return context.WithValue(ctx, keyPrivateServiceVariable{}, svcVar)
}

// PrivateServiceUnimplementedResolver a structure implemented to satisfy the Resolver interface.
// An Unimplemented error is always returned.
// This is intended for use when there are many Resolver interfaces that do not need to be implemented,
// by embedding them in a resolver structure that you have created.
type PrivateServiceUnimplementedResolver struct{}

// PrivateService represents Federation Service.
type PrivateService struct {
	UnimplementedPrivateServiceServer
	cfg                PrivateServiceConfig
	logger             *slog.Logger
	errorHandler       grpcfed.ErrorHandler
	celCacheMap        *grpcfed.CELCacheMap
	tracer             trace.Tracer
	env                *PrivateServiceEnv
	svcVar             *PrivateServiceVariable
	celTypeHelper      *grpcfed.CELTypeHelper
	celEnvOpts         []grpcfed.CELEnvOption
	celPluginInstances []*grpcfedcel.CELPluginInstance
	client             *PrivateServiceDependentClientSet
}

// NewPrivateService creates PrivateService instance by PrivateServiceConfig.
func NewPrivateService(cfg PrivateServiceConfig) (*PrivateService, error) {
	logger := cfg.Logger
	if logger == nil {
		logger = slog.New(slog.NewJSONHandler(io.Discard, nil))
	}
	errorHandler := cfg.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(ctx context.Context, methodName string, err error) error { return err }
	}
	celTypeHelperFieldMap := grpcfed.CELTypeHelperFieldMap{
		"grpc.federation.private.GetNameResponseArgument":     {},
		"grpc.federation.private.GetNameResponse_FooArgument": {},
		"grpc.federation.private.GetPostResponseArgument": {
			"id": grpcfed.NewCELFieldType(grpcfed.CELStringType, "Id"),
		},
		"grpc.federation.private.GetPostResponse_FooArgument": {},
		"grpc.federation.private.PostArgument":                {},
		"grpc.federation.private.ReactionArgument": {
			"v": grpcfed.NewCELFieldType(grpcfed.CELIntType, "V"),
		},
		"grpc.federation.private.UserArgument": {
			"id":   grpcfed.NewCELFieldType(grpcfed.CELStringType, "Id"),
			"name": grpcfed.NewCELFieldType(grpcfed.CELStringType, "Name"),
		},
		"grpc.federation.private.Env": {
			"name":    grpcfed.NewCELFieldType(grpcfed.CELStringType, "Name"),
			"private": grpcfed.NewCELFieldType(grpcfed.CELStringType, "Private"),
		},
		"grpc.federation.private.ServiceVariable": {
			"upper_name":                 grpcfed.NewCELFieldType(grpcfed.CELStringType, "UpperName"),
			"private_service_enum":       grpcfed.NewCELFieldType(grpcfed.CELIntType, "PrivateServiceEnum"),
			"private_service_user":       grpcfed.NewCELFieldType(grpcfed.NewCELObjectType("federation.User"), "PrivateServiceUser"),
			"users":                      grpcfed.NewCELFieldType(grpcfed.NewCELListType(grpcfed.NewCELObjectType("federation.User")), "Users"),
			"private_service_user_names": grpcfed.NewCELFieldType(grpcfed.NewCELListType(grpcfed.CELStringType), "PrivateServiceUserNames"),
			"foo_bar_baz":                grpcfed.NewCELFieldType(grpcfed.NewCELMapType(grpcfed.CELStringType, grpcfed.CELBoolType), "FooBarBaz"),
		},
	}
	celTypeHelper := grpcfed.NewCELTypeHelper("federation", celTypeHelperFieldMap)
	var celEnvOpts []grpcfed.CELEnvOption
	celEnvOpts = append(celEnvOpts, grpcfed.NewDefaultEnvOptions(celTypeHelper)...)
	celEnvOpts = append(celEnvOpts, grpcfed.EnumAccessorOptions("favorite.FavoriteType", favorite.FavoriteType_value, favorite.FavoriteType_name)...)
	celEnvOpts = append(celEnvOpts, grpcfed.EnumAccessorOptions("federation.MyFavoriteType", MyFavoriteType_value, MyFavoriteType_name)...)
	celEnvOpts = append(celEnvOpts, grpcfed.NewCELVariable("grpc.federation.env", grpcfed.CELObjectType("grpc.federation.private.Env")))
	celEnvOpts = append(celEnvOpts, grpcfed.NewCELVariable("grpc.federation.var", grpcfed.CELObjectType("grpc.federation.private.ServiceVariable")))
	var env PrivateServiceEnv
	if err := grpcfed.LoadEnv("", &env); err != nil {
		return nil, err
	}
	svc := &PrivateService{
		cfg:           cfg,
		logger:        logger,
		errorHandler:  errorHandler,
		celEnvOpts:    celEnvOpts,
		celTypeHelper: celTypeHelper,
		celCacheMap:   grpcfed.NewCELCacheMap(),
		tracer:        otel.Tracer("federation.PrivateService"),
		env:           &env,
		svcVar:        new(PrivateServiceVariable),
		client:        &PrivateServiceDependentClientSet{},
	}
	if err := svc.initServiceVariables(); err != nil {
		return nil, err
	}
	return svc, nil
}

// CleanupPrivateService cleanup all resources to prevent goroutine leaks.
func CleanupPrivateService(ctx context.Context, svc *PrivateService) {
	svc.cleanup(ctx)
}

func (s *PrivateService) cleanup(ctx context.Context) {
	for _, instance := range s.celPluginInstances {
		instance.Close(ctx)
	}
}
func (s *PrivateService) initServiceVariables() error {
	ctx := grpcfed.WithCELCacheMap(grpcfed.WithLogger(context.Background(), s.logger), s.celCacheMap)
	type localValueType struct {
		*grpcfed.LocalValue
		vars *PrivateServiceVariable
	}
	value := &localValueType{
		LocalValue: grpcfed.NewServiceVariableLocalValue(s.celEnvOpts),
		vars:       s.svcVar,
	}
	value.AddEnv(s.env)
	value.AddServiceVariable(s.svcVar)

	/*
		def {
		  name: "upper_name"
		  by: "grpc.federation.strings.toUpper(grpc.federation.env.name)"
		}
	*/
	def_upper_name := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[string, *localValueType]{
			Name: `upper_name`,
			Type: grpcfed.CELStringType,
			Setter: func(value *localValueType, v string) error {
				value.vars.UpperName = v
				return nil
			},
			By:           `grpc.federation.strings.toUpper(grpc.federation.env.name)`,
			ByCacheIndex: 1,
		})
	}
	if err := def_upper_name(ctx); err != nil {
		return err
	}

	/*
		def {
		  name: "private_service_enum"
		  enum {
		    name: "federation.MyFavoriteType"
		    by: "favorite.FavoriteType.value('TYPE_1')"
		  }
		}
	*/
	def_private_service_enum := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[MyFavoriteType, *localValueType]{
			Name: `private_service_enum`,
			Type: grpcfed.CELIntType,
			Setter: func(value *localValueType, v MyFavoriteType) error {
				value.vars.PrivateServiceEnum = v
				return nil
			},
			Enum: func(ctx context.Context, value *localValueType) (MyFavoriteType, error) {
				src, err := grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
					Value:      value,
					Expr:       `favorite.FavoriteType.value('TYPE_1')`,
					OutType:    reflect.TypeOf(favorite.FavoriteType(0)),
					CacheIndex: 2,
				})
				if err != nil {
					return 0, err
				}
				v := src.(favorite.FavoriteType)
				return s.cast_Favorite_FavoriteType__to__Federation_MyFavoriteType(v)
			},
		})
	}
	if err := def_private_service_enum(ctx); err != nil {
		return err
	}

	/*
		def {
		  name: "private_service_user"
		  message {
		    name: "User"
		    args: [
		      { name: "id", by: "'private_service_user_id'" },
		      { name: "name", by: "'private_service_user_name'" }
		    ]
		  }
		}
	*/
	def_private_service_user := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[*User, *localValueType]{
			Name: `private_service_user`,
			Type: grpcfed.CELObjectType("federation.User"),
			Setter: func(value *localValueType, v *User) error {
				value.vars.PrivateServiceUser = v
				return nil
			},
			Message: func(ctx context.Context, value *localValueType) (any, error) {
				args := &PrivateService_Federation_UserArgument{}
				// { name: "id", by: "'private_service_user_id'" }
				if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
					Value:      value,
					Expr:       `'private_service_user_id'`,
					CacheIndex: 3,
					Setter: func(v string) error {
						args.Id = v
						return nil
					},
				}); err != nil {
					return nil, err
				}
				// { name: "name", by: "'private_service_user_name'" }
				if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
					Value:      value,
					Expr:       `'private_service_user_name'`,
					CacheIndex: 4,
					Setter: func(v string) error {
						args.Name = v
						return nil
					},
				}); err != nil {
					return nil, err
				}
				ret, err := s.resolve_Federation_User(ctx, args)
				if err != nil {
					return nil, err
				}
				return ret, nil
			},
		})
	}
	if err := def_private_service_user(ctx); err != nil {
		return err
	}

	/*
		def {
		  name: "users"
		  by: "[private_service_user]"
		}
	*/
	def_users := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[[]*User, *localValueType]{
			Name: `users`,
			Type: grpcfed.CELListType(grpcfed.CELObjectType("federation.User")),
			Setter: func(value *localValueType, v []*User) error {
				value.vars.Users = v
				return nil
			},
			By:           `[private_service_user]`,
			ByCacheIndex: 5,
		})
	}
	if err := def_users(ctx); err != nil {
		return err
	}

	/*
		def {
		  name: "private_service_user_names"
		  map {
		    iterator {
		      name: "iter"
		      src: "users"
		    }
		    by: "iter.name"
		  }
		}
	*/
	def_private_service_user_names := func(ctx context.Context) error {
		return grpcfed.EvalDefMap(ctx, value, grpcfed.DefMap[[]string, *User, *localValueType]{
			Name: `private_service_user_names`,
			Type: grpcfed.CELListType(grpcfed.CELStringType),
			Setter: func(value *localValueType, v []string) error {
				value.vars.PrivateServiceUserNames = v
				return nil
			},
			IteratorName:   `iter`,
			IteratorType:   grpcfed.CELObjectType("federation.User"),
			IteratorSource: func(value *localValueType) []*User { return value.vars.Users },
			Iterator: func(ctx context.Context, value *grpcfed.MapIteratorValue) (any, error) {
				return grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
					Value:      value,
					Expr:       `iter.name`,
					OutType:    reflect.TypeOf(""),
					CacheIndex: 6,
				})
			},
		})
	}
	if err := def_private_service_user_names(ctx); err != nil {
		return err
	}

	/*
		def {
		  name: "foo_bar_baz"
		  by: "{'b': true}"
		}
	*/
	def_foo_bar_baz := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[map[string]bool, *localValueType]{
			Name: `foo_bar_baz`,
			Type: grpcfed.NewCELMapType(grpcfed.CELStringType, grpcfed.CELBoolType),
			Setter: func(value *localValueType, v map[string]bool) error {
				value.vars.FooBarBaz = v
				return nil
			},
			By:           `{'b': true}`,
			ByCacheIndex: 7,
		})
	}
	if err := def_foo_bar_baz(ctx); err != nil {
		return err
	}

	return nil
}

// GetPost implements "federation.PrivateService/GetPost" method.
func (s *PrivateService) GetPost(ctx context.Context, req *GetPostRequest) (res *GetPostResponse, e error) {
	ctx, span := s.tracer.Start(ctx, "federation.PrivateService/GetPost")
	defer span.End()
	ctx = withPrivateServiceEnv(ctx, s.env)
	ctx = withPrivateServiceVariable(ctx, s.svcVar)
	ctx = grpcfed.WithLogger(ctx, s.logger)
	ctx = grpcfed.WithCELCacheMap(ctx, s.celCacheMap)
	defer func() {
		if r := recover(); r != nil {
			e = grpcfed.RecoverError(r, grpcfed.StackTrace())
			grpcfed.OutputErrorLog(ctx, e)
		}
	}()
	res, err := s.resolve_Federation_GetPostResponse(ctx, &PrivateService_Federation_GetPostResponseArgument{
		Id: req.GetId(),
	})
	if err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		grpcfed.OutputErrorLog(ctx, err)
		return nil, err
	}
	return res, nil
}

// GetName implements "federation.PrivateService/GetName" method.
func (s *PrivateService) GetName(ctx context.Context, req *GetNameRequest) (res *GetNameResponse, e error) {
	ctx, span := s.tracer.Start(ctx, "federation.PrivateService/GetName")
	defer span.End()
	ctx = withPrivateServiceEnv(ctx, s.env)
	ctx = withPrivateServiceVariable(ctx, s.svcVar)
	ctx = grpcfed.WithLogger(ctx, s.logger)
	ctx = grpcfed.WithCELCacheMap(ctx, s.celCacheMap)
	defer func() {
		if r := recover(); r != nil {
			e = grpcfed.RecoverError(r, grpcfed.StackTrace())
			grpcfed.OutputErrorLog(ctx, e)
		}
	}()
	res, err := s.resolve_Federation_GetNameResponse(ctx, &PrivateService_Federation_GetNameResponseArgument{})
	if err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		grpcfed.OutputErrorLog(ctx, err)
		return nil, err
	}
	return res, nil
}

// resolve_Federation_GetNameResponse resolve "federation.GetNameResponse" message.
func (s *PrivateService) resolve_Federation_GetNameResponse(ctx context.Context, req *PrivateService_Federation_GetNameResponseArgument) (*GetNameResponse, error) {
	ctx, span := s.tracer.Start(ctx, "federation.GetNameResponse")
	defer span.End()
	ctx = grpcfed.WithLogger(ctx, grpcfed.Logger(ctx), grpcfed.LogAttrs(ctx)...)

	grpcfed.Logger(ctx).DebugContext(ctx, "resolve federation.GetNameResponse", slog.Any("message_args", s.logvalue_Federation_GetNameResponseArgument(req)))
	type localValueType struct {
		*grpcfed.LocalValue
		vars struct {
			Foo *GetNameResponse_Foo
		}
	}
	value := &localValueType{LocalValue: grpcfed.NewLocalValue(ctx, s.celEnvOpts, "grpc.federation.private.GetNameResponseArgument", req)}
	value.AddEnv(s.env)
	value.AddServiceVariable(s.svcVar)
	/*
		def {
		  name: "foo"
		  message {
		    name: "Foo"
		  }
		}
	*/
	def_foo := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[*GetNameResponse_Foo, *localValueType]{
			Name: `foo`,
			Type: grpcfed.CELObjectType("federation.GetNameResponse.Foo"),
			Setter: func(value *localValueType, v *GetNameResponse_Foo) error {
				value.vars.Foo = v
				return nil
			},
			Message: func(ctx context.Context, value *localValueType) (any, error) {
				args := &PrivateService_Federation_GetNameResponse_FooArgument{}
				ret, err := s.resolve_Federation_GetNameResponse_Foo(ctx, args)
				if err != nil {
					return nil, err
				}
				return ret, nil
			},
		})
	}

	if err := def_foo(ctx); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}

	// assign named parameters to message arguments to pass to the custom resolver.
	req.Foo = value.vars.Foo

	// create a message value to be returned.
	ret := &GetNameResponse{}

	// field binding section.
	// (grpc.federation.field).by = "grpc.federation.env.name"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
		Value:      value,
		Expr:       `grpc.federation.env.name`,
		CacheIndex: 8,
		Setter: func(v string) error {
			ret.Name = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "foo"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[*GetNameResponse_Foo]{
		Value:      value,
		Expr:       `foo`,
		CacheIndex: 9,
		Setter: func(v *GetNameResponse_Foo) error {
			ret.Foo = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}

	grpcfed.Logger(ctx).DebugContext(ctx, "resolved federation.GetNameResponse", slog.Any("federation.GetNameResponse", s.logvalue_Federation_GetNameResponse(ret)))
	return ret, nil
}

// resolve_Federation_GetNameResponse_Foo resolve "federation.GetNameResponse.Foo" message.
func (s *PrivateService) resolve_Federation_GetNameResponse_Foo(ctx context.Context, req *PrivateService_Federation_GetNameResponse_FooArgument) (*GetNameResponse_Foo, error) {
	ctx, span := s.tracer.Start(ctx, "federation.GetNameResponse.Foo")
	defer span.End()
	ctx = grpcfed.WithLogger(ctx, grpcfed.Logger(ctx), grpcfed.LogAttrs(ctx)...)

	grpcfed.Logger(ctx).DebugContext(ctx, "resolve federation.GetNameResponse.Foo", slog.Any("message_args", s.logvalue_Federation_GetNameResponse_FooArgument(req)))
	type localValueType struct {
		*grpcfed.LocalValue
		vars struct {
		}
	}
	value := &localValueType{LocalValue: grpcfed.NewLocalValue(ctx, s.celEnvOpts, "grpc.federation.private.GetNameResponse_FooArgument", req)}
	value.AddEnv(s.env)
	value.AddServiceVariable(s.svcVar)

	// create a message value to be returned.
	ret := &GetNameResponse_Foo{}

	// field binding section.
	// (grpc.federation.field).by = "'y'"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
		Value:      value,
		Expr:       `'y'`,
		CacheIndex: 10,
		Setter: func(v string) error {
			ret.Y = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}

	grpcfed.Logger(ctx).DebugContext(ctx, "resolved federation.GetNameResponse.Foo", slog.Any("federation.GetNameResponse.Foo", s.logvalue_Federation_GetNameResponse_Foo(ret)))
	return ret, nil
}

// resolve_Federation_GetPostResponse resolve "federation.GetPostResponse" message.
func (s *PrivateService) resolve_Federation_GetPostResponse(ctx context.Context, req *PrivateService_Federation_GetPostResponseArgument) (*GetPostResponse, error) {
	ctx, span := s.tracer.Start(ctx, "federation.GetPostResponse")
	defer span.End()
	ctx = grpcfed.WithLogger(ctx, grpcfed.Logger(ctx), grpcfed.LogAttrs(ctx)...)

	grpcfed.Logger(ctx).DebugContext(ctx, "resolve federation.GetPostResponse", slog.Any("message_args", s.logvalue_Federation_GetPostResponseArgument(req)))
	type localValueType struct {
		*grpcfed.LocalValue
		vars struct {
			Foo *GetPostResponse_Foo
			P   *Post
		}
	}
	value := &localValueType{LocalValue: grpcfed.NewLocalValue(ctx, s.celEnvOpts, "grpc.federation.private.GetPostResponseArgument", req)}
	value.AddEnv(s.env)
	value.AddServiceVariable(s.svcVar)
	/*
		def {
		  name: "p"
		  message {
		    name: "Post"
		  }
		}
	*/
	def_p := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[*Post, *localValueType]{
			Name: `p`,
			Type: grpcfed.CELObjectType("federation.Post"),
			Setter: func(value *localValueType, v *Post) error {
				value.vars.P = v
				return nil
			},
			Message: func(ctx context.Context, value *localValueType) (any, error) {
				args := &PrivateService_Federation_PostArgument{}
				ret, err := s.resolve_Federation_Post(ctx, args)
				if err != nil {
					return nil, err
				}
				return ret, nil
			},
		})
	}

	/*
		def {
		  name: "foo"
		  message {
		    name: "Foo"
		  }
		}
	*/
	def_foo := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[*GetPostResponse_Foo, *localValueType]{
			Name: `foo`,
			Type: grpcfed.CELObjectType("federation.GetPostResponse.Foo"),
			Setter: func(value *localValueType, v *GetPostResponse_Foo) error {
				value.vars.Foo = v
				return nil
			},
			Message: func(ctx context.Context, value *localValueType) (any, error) {
				args := &PrivateService_Federation_GetPostResponse_FooArgument{}
				ret, err := s.resolve_Federation_GetPostResponse_Foo(ctx, args)
				if err != nil {
					return nil, err
				}
				return ret, nil
			},
		})
	}

	// A tree view of message dependencies is shown below.
	/*
	   foo ─┐
	     p ─┤
	*/
	eg, ctx1 := grpcfed.ErrorGroupWithContext(ctx)

	grpcfed.GoWithRecover(eg, func() (any, error) {
		if err := def_foo(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		return nil, nil
	})

	grpcfed.GoWithRecover(eg, func() (any, error) {
		if err := def_p(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		return nil, nil
	})

	if err := eg.Wait(); err != nil {
		return nil, err
	}

	// assign named parameters to message arguments to pass to the custom resolver.
	req.Foo = value.vars.Foo
	req.P = value.vars.P

	// create a message value to be returned.
	ret := &GetPostResponse{}

	// field binding section.
	// (grpc.federation.field).by = "p"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[*Post]{
		Value:      value,
		Expr:       `p`,
		CacheIndex: 11,
		Setter: func(v *Post) error {
			ret.Post = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "grpc.federation.var.upper_name"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
		Value:      value,
		Expr:       `grpc.federation.var.upper_name`,
		CacheIndex: 12,
		Setter: func(v string) error {
			ret.UpperName = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "foo"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[*GetPostResponse_Foo]{
		Value:      value,
		Expr:       `foo`,
		CacheIndex: 13,
		Setter: func(v *GetPostResponse_Foo) error {
			ret.Foo = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}

	grpcfed.Logger(ctx).DebugContext(ctx, "resolved federation.GetPostResponse", slog.Any("federation.GetPostResponse", s.logvalue_Federation_GetPostResponse(ret)))
	return ret, nil
}

// resolve_Federation_GetPostResponse_Foo resolve "federation.GetPostResponse.Foo" message.
func (s *PrivateService) resolve_Federation_GetPostResponse_Foo(ctx context.Context, req *PrivateService_Federation_GetPostResponse_FooArgument) (*GetPostResponse_Foo, error) {
	ctx, span := s.tracer.Start(ctx, "federation.GetPostResponse.Foo")
	defer span.End()
	ctx = grpcfed.WithLogger(ctx, grpcfed.Logger(ctx), grpcfed.LogAttrs(ctx)...)

	grpcfed.Logger(ctx).DebugContext(ctx, "resolve federation.GetPostResponse.Foo", slog.Any("message_args", s.logvalue_Federation_GetPostResponse_FooArgument(req)))
	type localValueType struct {
		*grpcfed.LocalValue
		vars struct {
		}
	}
	value := &localValueType{LocalValue: grpcfed.NewLocalValue(ctx, s.celEnvOpts, "grpc.federation.private.GetPostResponse_FooArgument", req)}
	value.AddEnv(s.env)
	value.AddServiceVariable(s.svcVar)

	// create a message value to be returned.
	ret := &GetPostResponse_Foo{}

	// field binding section.
	// (grpc.federation.field).by = "'x'"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
		Value:      value,
		Expr:       `'x'`,
		CacheIndex: 14,
		Setter: func(v string) error {
			ret.X = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}

	grpcfed.Logger(ctx).DebugContext(ctx, "resolved federation.GetPostResponse.Foo", slog.Any("federation.GetPostResponse.Foo", s.logvalue_Federation_GetPostResponse_Foo(ret)))
	return ret, nil
}

// resolve_Federation_Post resolve "federation.Post" message.
func (s *PrivateService) resolve_Federation_Post(ctx context.Context, req *PrivateService_Federation_PostArgument) (*Post, error) {
	ctx, span := s.tracer.Start(ctx, "federation.Post")
	defer span.End()
	ctx = grpcfed.WithLogger(ctx, grpcfed.Logger(ctx), grpcfed.LogAttrs(ctx)...)

	grpcfed.Logger(ctx).DebugContext(ctx, "resolve federation.Post", slog.Any("message_args", s.logvalue_Federation_PostArgument(req)))
	type localValueType struct {
		*grpcfed.LocalValue
		vars struct {
			Cmp           bool
			FavoriteValue favorite.FavoriteType
			Reaction      *Reaction
			U             *User
		}
	}
	value := &localValueType{LocalValue: grpcfed.NewLocalValue(ctx, s.celEnvOpts, "grpc.federation.private.PostArgument", req)}
	value.AddEnv(s.env)
	value.AddServiceVariable(s.svcVar)
	/*
		def {
		  name: "u"
		  message {
		    name: "User"
		    args: [
		      { name: "id", by: "'foo'" },
		      { name: "name", by: "'bar'" }
		    ]
		  }
		}
	*/
	def_u := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[*User, *localValueType]{
			Name: `u`,
			Type: grpcfed.CELObjectType("federation.User"),
			Setter: func(value *localValueType, v *User) error {
				value.vars.U = v
				return nil
			},
			Message: func(ctx context.Context, value *localValueType) (any, error) {
				args := &PrivateService_Federation_UserArgument{}
				// { name: "id", by: "'foo'" }
				if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
					Value:      value,
					Expr:       `'foo'`,
					CacheIndex: 15,
					Setter: func(v string) error {
						args.Id = v
						return nil
					},
				}); err != nil {
					return nil, err
				}
				// { name: "name", by: "'bar'" }
				if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
					Value:      value,
					Expr:       `'bar'`,
					CacheIndex: 16,
					Setter: func(v string) error {
						args.Name = v
						return nil
					},
				}); err != nil {
					return nil, err
				}
				ret, err := s.resolve_Federation_User(ctx, args)
				if err != nil {
					return nil, err
				}
				return ret, nil
			},
		})
	}

	/*
		def {
		  name: "favorite_value"
		  by: "favorite.FavoriteType.value('TYPE1')"
		}
	*/
	def_favorite_value := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[favorite.FavoriteType, *localValueType]{
			Name: `favorite_value`,
			Type: grpcfed.CELIntType,
			Setter: func(value *localValueType, v favorite.FavoriteType) error {
				value.vars.FavoriteValue = v
				return nil
			},
			By:           `favorite.FavoriteType.value('TYPE1')`,
			ByCacheIndex: 17,
		})
	}

	/*
		def {
		  name: "cmp"
		  by: "favorite_value == favorite.FavoriteType.TYPE1"
		}
	*/
	def_cmp := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[bool, *localValueType]{
			Name: `cmp`,
			Type: grpcfed.CELBoolType,
			Setter: func(value *localValueType, v bool) error {
				value.vars.Cmp = v
				return nil
			},
			By:           `favorite_value == favorite.FavoriteType.TYPE1`,
			ByCacheIndex: 18,
		})
	}

	/*
		def {
		  name: "reaction"
		  message {
		    name: "Reaction"
		    args { name: "v", by: "favorite_value" }
		  }
		}
	*/
	def_reaction := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[*Reaction, *localValueType]{
			Name: `reaction`,
			Type: grpcfed.CELObjectType("federation.Reaction"),
			Setter: func(value *localValueType, v *Reaction) error {
				value.vars.Reaction = v
				return nil
			},
			Message: func(ctx context.Context, value *localValueType) (any, error) {
				args := &PrivateService_Federation_ReactionArgument{}
				// { name: "v", by: "favorite_value" }
				if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[favorite.FavoriteType]{
					Value:      value,
					Expr:       `favorite_value`,
					CacheIndex: 19,
					Setter: func(v favorite.FavoriteType) error {
						args.V = v
						return nil
					},
				}); err != nil {
					return nil, err
				}
				ret, err := s.resolve_Federation_Reaction(ctx, args)
				if err != nil {
					return nil, err
				}
				return ret, nil
			},
		})
	}

	// A tree view of message dependencies is shown below.
	/*
	   favorite_value ─┐
	                        cmp ─┐
	   favorite_value ─┐         │
	                   reaction ─┤
	                          u ─┤
	*/
	eg, ctx1 := grpcfed.ErrorGroupWithContext(ctx)

	grpcfed.GoWithRecover(eg, func() (any, error) {
		if err := def_favorite_value(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		if err := def_cmp(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		return nil, nil
	})

	grpcfed.GoWithRecover(eg, func() (any, error) {
		if err := def_favorite_value(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		if err := def_reaction(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		return nil, nil
	})

	grpcfed.GoWithRecover(eg, func() (any, error) {
		if err := def_u(ctx1); err != nil {
			grpcfed.RecordErrorToSpan(ctx1, err)
			return nil, err
		}
		return nil, nil
	})

	if err := eg.Wait(); err != nil {
		return nil, err
	}

	// assign named parameters to message arguments to pass to the custom resolver.
	req.Cmp = value.vars.Cmp
	req.FavoriteValue = value.vars.FavoriteValue
	req.Reaction = value.vars.Reaction
	req.U = value.vars.U

	// create a message value to be returned.
	ret := &Post{}

	// field binding section.
	// (grpc.federation.field).by = "'post-id'"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
		Value:      value,
		Expr:       `'post-id'`,
		CacheIndex: 20,
		Setter: func(v string) error {
			ret.Id = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "'title'"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
		Value:      value,
		Expr:       `'title'`,
		CacheIndex: 21,
		Setter: func(v string) error {
			ret.Title = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "'content'"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
		Value:      value,
		Expr:       `'content'`,
		CacheIndex: 22,
		Setter: func(v string) error {
			ret.Content = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "u"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[*User]{
		Value:      value,
		Expr:       `u`,
		CacheIndex: 23,
		Setter: func(v *User) error {
			ret.User = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "reaction"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[*Reaction]{
		Value:      value,
		Expr:       `reaction`,
		CacheIndex: 24,
		Setter: func(v *Reaction) error {
			ret.Reaction = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "favorite_value"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[favorite.FavoriteType]{
		Value:      value,
		Expr:       `favorite_value`,
		CacheIndex: 25,
		Setter: func(v favorite.FavoriteType) error {
			favoriteValueValue, err := s.cast_Favorite_FavoriteType__to__Federation_MyFavoriteType(v)
			if err != nil {
				return err
			}
			ret.FavoriteValue = favoriteValueValue
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "cmp"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[bool]{
		Value:      value,
		Expr:       `cmp`,
		CacheIndex: 26,
		Setter: func(v bool) error {
			ret.Cmp = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}

	grpcfed.Logger(ctx).DebugContext(ctx, "resolved federation.Post", slog.Any("federation.Post", s.logvalue_Federation_Post(ret)))
	return ret, nil
}

// resolve_Federation_Reaction resolve "federation.Reaction" message.
func (s *PrivateService) resolve_Federation_Reaction(ctx context.Context, req *PrivateService_Federation_ReactionArgument) (*Reaction, error) {
	ctx, span := s.tracer.Start(ctx, "federation.Reaction")
	defer span.End()
	ctx = grpcfed.WithLogger(ctx, grpcfed.Logger(ctx), grpcfed.LogAttrs(ctx)...)

	grpcfed.Logger(ctx).DebugContext(ctx, "resolve federation.Reaction", slog.Any("message_args", s.logvalue_Federation_ReactionArgument(req)))
	type localValueType struct {
		*grpcfed.LocalValue
		vars struct {
			Cmp bool
		}
	}
	value := &localValueType{LocalValue: grpcfed.NewLocalValue(ctx, s.celEnvOpts, "grpc.federation.private.ReactionArgument", req)}
	value.AddEnv(s.env)
	value.AddServiceVariable(s.svcVar)
	/*
		def {
		  name: "cmp"
		  by: "$.v == favorite.FavoriteType.TYPE1"
		}
	*/
	def_cmp := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[bool, *localValueType]{
			Name: `cmp`,
			Type: grpcfed.CELBoolType,
			Setter: func(value *localValueType, v bool) error {
				value.vars.Cmp = v
				return nil
			},
			By:           `$.v == favorite.FavoriteType.TYPE1`,
			ByCacheIndex: 27,
		})
	}

	if err := def_cmp(ctx); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}

	// assign named parameters to message arguments to pass to the custom resolver.
	req.Cmp = value.vars.Cmp

	// create a message value to be returned.
	ret := &Reaction{}

	// field binding section.
	// (grpc.federation.field).by = "favorite.FavoriteType.value('TYPE1')"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[favorite.FavoriteType]{
		Value:      value,
		Expr:       `favorite.FavoriteType.value('TYPE1')`,
		CacheIndex: 28,
		Setter: func(v favorite.FavoriteType) error {
			ret.FavoriteType = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "favorite.FavoriteType.name(favorite.FavoriteType.value('TYPE1'))"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
		Value:      value,
		Expr:       `favorite.FavoriteType.name(favorite.FavoriteType.value('TYPE1'))`,
		CacheIndex: 29,
		Setter: func(v string) error {
			ret.FavoriteTypeStr = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "cmp"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[bool]{
		Value:      value,
		Expr:       `cmp`,
		CacheIndex: 30,
		Setter: func(v bool) error {
			ret.Cmp = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}

	grpcfed.Logger(ctx).DebugContext(ctx, "resolved federation.Reaction", slog.Any("federation.Reaction", s.logvalue_Federation_Reaction(ret)))
	return ret, nil
}

// resolve_Federation_User resolve "federation.User" message.
func (s *PrivateService) resolve_Federation_User(ctx context.Context, req *PrivateService_Federation_UserArgument) (*User, error) {
	ctx, span := s.tracer.Start(ctx, "federation.User")
	defer span.End()
	ctx = grpcfed.WithLogger(ctx, grpcfed.Logger(ctx), grpcfed.LogAttrs(ctx)...)

	grpcfed.Logger(ctx).DebugContext(ctx, "resolve federation.User", slog.Any("message_args", s.logvalue_Federation_UserArgument(req)))
	type localValueType struct {
		*grpcfed.LocalValue
		vars struct {
		}
	}
	value := &localValueType{LocalValue: grpcfed.NewLocalValue(ctx, s.celEnvOpts, "grpc.federation.private.UserArgument", req)}
	value.AddEnv(s.env)
	value.AddServiceVariable(s.svcVar)

	// create a message value to be returned.
	ret := &User{}

	// field binding section.
	// (grpc.federation.field).by = "$.id"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
		Value:      value,
		Expr:       `$.id`,
		CacheIndex: 31,
		Setter: func(v string) error {
			ret.Id = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "$.name"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
		Value:      value,
		Expr:       `$.name`,
		CacheIndex: 32,
		Setter: func(v string) error {
			ret.Name = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}

	grpcfed.Logger(ctx).DebugContext(ctx, "resolved federation.User", slog.Any("federation.User", s.logvalue_Federation_User(ret)))
	return ret, nil
}

// cast_Favorite_FavoriteType__to__Federation_MyFavoriteType cast from "favorite.FavoriteType" to "federation.MyFavoriteType".
func (s *PrivateService) cast_Favorite_FavoriteType__to__Federation_MyFavoriteType(from favorite.FavoriteType) (MyFavoriteType, error) {
	var ret MyFavoriteType
	switch from {
	case favorite.FavoriteType_UNKNOWN:
		ret = MyFavoriteType_UNKNOWN
	case favorite.FavoriteType_TYPE1:
		ret = MyFavoriteType_TYPE1
	default:
		ret = 0
	}
	return ret, nil
}

func (s *PrivateService) logvalue_Favorite_FavoriteType(v favorite.FavoriteType) slog.Value {
	switch v {
	case favorite.FavoriteType_UNKNOWN:
		return slog.StringValue("UNKNOWN")
	case favorite.FavoriteType_TYPE1:
		return slog.StringValue("TYPE1")
	case favorite.FavoriteType_TYPE2:
		return slog.StringValue("TYPE2")
	}
	return slog.StringValue("")
}

func (s *PrivateService) logvalue_Federation_GetNameResponse(v *GetNameResponse) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("name", v.GetName()),
		slog.Any("foo", s.logvalue_Federation_GetNameResponse_Foo(v.GetFoo())),
	)
}

func (s *PrivateService) logvalue_Federation_GetNameResponseArgument(v *PrivateService_Federation_GetNameResponseArgument) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue()
}

func (s *PrivateService) logvalue_Federation_GetNameResponse_Foo(v *GetNameResponse_Foo) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("y", v.GetY()),
	)
}

func (s *PrivateService) logvalue_Federation_GetNameResponse_FooArgument(v *PrivateService_Federation_GetNameResponse_FooArgument) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue()
}

func (s *PrivateService) logvalue_Federation_GetPostResponse(v *GetPostResponse) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.Any("post", s.logvalue_Federation_Post(v.GetPost())),
		slog.String("upper_name", v.GetUpperName()),
		slog.Any("foo", s.logvalue_Federation_GetPostResponse_Foo(v.GetFoo())),
	)
}

func (s *PrivateService) logvalue_Federation_GetPostResponseArgument(v *PrivateService_Federation_GetPostResponseArgument) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("id", v.Id),
	)
}

func (s *PrivateService) logvalue_Federation_GetPostResponse_Foo(v *GetPostResponse_Foo) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("x", v.GetX()),
	)
}

func (s *PrivateService) logvalue_Federation_GetPostResponse_FooArgument(v *PrivateService_Federation_GetPostResponse_FooArgument) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue()
}

func (s *PrivateService) logvalue_Federation_MyFavoriteType(v MyFavoriteType) slog.Value {
	switch v {
	case MyFavoriteType_UNKNOWN:
		return slog.StringValue("UNKNOWN")
	case MyFavoriteType_TYPE1:
		return slog.StringValue("TYPE1")
	}
	return slog.StringValue("")
}

func (s *PrivateService) logvalue_Federation_Post(v *Post) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("id", v.GetId()),
		slog.String("title", v.GetTitle()),
		slog.String("content", v.GetContent()),
		slog.Any("user", s.logvalue_Federation_User(v.GetUser())),
		slog.Any("reaction", s.logvalue_Federation_Reaction(v.GetReaction())),
		slog.String("favorite_value", s.logvalue_Federation_MyFavoriteType(v.GetFavoriteValue()).String()),
		slog.Bool("cmp", v.GetCmp()),
	)
}

func (s *PrivateService) logvalue_Federation_PostArgument(v *PrivateService_Federation_PostArgument) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue()
}

func (s *PrivateService) logvalue_Federation_Reaction(v *Reaction) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("favorite_type", s.logvalue_Favorite_FavoriteType(v.GetFavoriteType()).String()),
		slog.String("favorite_type_str", v.GetFavoriteTypeStr()),
		slog.Bool("cmp", v.GetCmp()),
	)
}

func (s *PrivateService) logvalue_Federation_ReactionArgument(v *PrivateService_Federation_ReactionArgument) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("v", s.logvalue_Favorite_FavoriteType(v.V).String()),
	)
}

func (s *PrivateService) logvalue_Federation_User(v *User) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("id", v.GetId()),
		slog.String("name", v.GetName()),
	)
}

func (s *PrivateService) logvalue_Federation_UserArgument(v *PrivateService_Federation_UserArgument) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("id", v.Id),
		slog.String("name", v.Name),
	)
}

// Federation_GetStatusResponseArgument is argument for "federation.GetStatusResponse" message.
type DebugService_Federation_GetStatusResponseArgument struct {
	U *User
}

// Federation_UserArgument is argument for "federation.User" message.
type DebugService_Federation_UserArgument struct {
	Id   string
	Name string
}

// DebugServiceConfig configuration required to initialize the service that use GRPC Federation.
type DebugServiceConfig struct {
	// ErrorHandler Federation Service often needs to convert errors received from downstream services.
	// If an error occurs during method execution in the Federation Service, this error handler is called and the returned error is treated as a final error.
	ErrorHandler grpcfed.ErrorHandler
	// Logger sets the logger used to output Debug/Info/Error information.
	Logger *slog.Logger
}

// DebugServiceClientFactory provides a factory that creates the gRPC Client needed to invoke methods of the gRPC Service on which the Federation Service depends.
type DebugServiceClientFactory interface {
}

// DebugServiceClientConfig helper to create gRPC client.
// Hints for creating a gRPC Client.
type DebugServiceClientConfig struct {
	// Service FQDN ( `<package-name>.<service-name>` ) of the service on Protocol Buffers.
	Service string
}

// DebugServiceDependentClientSet has a gRPC client for all services on which the federation service depends.
// This is provided as an argument when implementing the custom resolver.
type DebugServiceDependentClientSet struct {
}

// DebugServiceResolver provides an interface to directly implement message resolver and field resolver not defined in Protocol Buffers.
type DebugServiceResolver interface {
}

// DebugServiceCELPluginWasmConfig type alias for grpcfedcel.WasmConfig.
type DebugServiceCELPluginWasmConfig = grpcfedcel.WasmConfig

// DebugServiceCELPluginConfig hints for loading a WebAssembly based plugin.
type DebugServiceCELPluginConfig struct {
}

// DebugServiceUnimplementedResolver a structure implemented to satisfy the Resolver interface.
// An Unimplemented error is always returned.
// This is intended for use when there are many Resolver interfaces that do not need to be implemented,
// by embedding them in a resolver structure that you have created.
type DebugServiceUnimplementedResolver struct{}

// DebugService represents Federation Service.
type DebugService struct {
	UnimplementedDebugServiceServer
	cfg                DebugServiceConfig
	logger             *slog.Logger
	errorHandler       grpcfed.ErrorHandler
	celCacheMap        *grpcfed.CELCacheMap
	tracer             trace.Tracer
	celTypeHelper      *grpcfed.CELTypeHelper
	celEnvOpts         []grpcfed.CELEnvOption
	celPluginInstances []*grpcfedcel.CELPluginInstance
	client             *DebugServiceDependentClientSet
}

// NewDebugService creates DebugService instance by DebugServiceConfig.
func NewDebugService(cfg DebugServiceConfig) (*DebugService, error) {
	logger := cfg.Logger
	if logger == nil {
		logger = slog.New(slog.NewJSONHandler(io.Discard, nil))
	}
	errorHandler := cfg.ErrorHandler
	if errorHandler == nil {
		errorHandler = func(ctx context.Context, methodName string, err error) error { return err }
	}
	celTypeHelperFieldMap := grpcfed.CELTypeHelperFieldMap{
		"grpc.federation.private.GetStatusResponseArgument": {},
		"grpc.federation.private.UserArgument": {
			"id":   grpcfed.NewCELFieldType(grpcfed.CELStringType, "Id"),
			"name": grpcfed.NewCELFieldType(grpcfed.CELStringType, "Name"),
		},
	}
	celTypeHelper := grpcfed.NewCELTypeHelper("federation", celTypeHelperFieldMap)
	var celEnvOpts []grpcfed.CELEnvOption
	celEnvOpts = append(celEnvOpts, grpcfed.NewDefaultEnvOptions(celTypeHelper)...)
	celEnvOpts = append(celEnvOpts, grpcfed.EnumAccessorOptions("favorite.FavoriteType", favorite.FavoriteType_value, favorite.FavoriteType_name)...)
	celEnvOpts = append(celEnvOpts, grpcfed.EnumAccessorOptions("federation.MyFavoriteType", MyFavoriteType_value, MyFavoriteType_name)...)
	svc := &DebugService{
		cfg:           cfg,
		logger:        logger,
		errorHandler:  errorHandler,
		celEnvOpts:    celEnvOpts,
		celTypeHelper: celTypeHelper,
		celCacheMap:   grpcfed.NewCELCacheMap(),
		tracer:        otel.Tracer("federation.DebugService"),
		client:        &DebugServiceDependentClientSet{},
	}
	return svc, nil
}

// CleanupDebugService cleanup all resources to prevent goroutine leaks.
func CleanupDebugService(ctx context.Context, svc *DebugService) {
	svc.cleanup(ctx)
}

func (s *DebugService) cleanup(ctx context.Context) {
	for _, instance := range s.celPluginInstances {
		instance.Close(ctx)
	}
}

// GetStatus implements "federation.DebugService/GetStatus" method.
func (s *DebugService) GetStatus(ctx context.Context, req *GetStatusRequest) (res *GetStatusResponse, e error) {
	ctx, span := s.tracer.Start(ctx, "federation.DebugService/GetStatus")
	defer span.End()
	ctx = grpcfed.WithLogger(ctx, s.logger)
	ctx = grpcfed.WithCELCacheMap(ctx, s.celCacheMap)
	defer func() {
		if r := recover(); r != nil {
			e = grpcfed.RecoverError(r, grpcfed.StackTrace())
			grpcfed.OutputErrorLog(ctx, e)
		}
	}()
	res, err := s.resolve_Federation_GetStatusResponse(ctx, &DebugService_Federation_GetStatusResponseArgument{})
	if err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		grpcfed.OutputErrorLog(ctx, err)
		return nil, err
	}
	return res, nil
}

// resolve_Federation_GetStatusResponse resolve "federation.GetStatusResponse" message.
func (s *DebugService) resolve_Federation_GetStatusResponse(ctx context.Context, req *DebugService_Federation_GetStatusResponseArgument) (*GetStatusResponse, error) {
	ctx, span := s.tracer.Start(ctx, "federation.GetStatusResponse")
	defer span.End()
	ctx = grpcfed.WithLogger(ctx, grpcfed.Logger(ctx), grpcfed.LogAttrs(ctx)...)

	grpcfed.Logger(ctx).DebugContext(ctx, "resolve federation.GetStatusResponse", slog.Any("message_args", s.logvalue_Federation_GetStatusResponseArgument(req)))
	type localValueType struct {
		*grpcfed.LocalValue
		vars struct {
			U *User
		}
	}
	value := &localValueType{LocalValue: grpcfed.NewLocalValue(ctx, s.celEnvOpts, "grpc.federation.private.GetStatusResponseArgument", req)}
	/*
		def {
		  name: "u"
		  message {
		    name: "User"
		    args: [
		      { name: "id", by: "'xxxx'" },
		      { name: "name", by: "'yyyy'" }
		    ]
		  }
		}
	*/
	def_u := func(ctx context.Context) error {
		return grpcfed.EvalDef(ctx, value, grpcfed.Def[*User, *localValueType]{
			Name: `u`,
			Type: grpcfed.CELObjectType("federation.User"),
			Setter: func(value *localValueType, v *User) error {
				value.vars.U = v
				return nil
			},
			Message: func(ctx context.Context, value *localValueType) (any, error) {
				args := &DebugService_Federation_UserArgument{}
				// { name: "id", by: "'xxxx'" }
				if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
					Value:      value,
					Expr:       `'xxxx'`,
					CacheIndex: 1,
					Setter: func(v string) error {
						args.Id = v
						return nil
					},
				}); err != nil {
					return nil, err
				}
				// { name: "name", by: "'yyyy'" }
				if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
					Value:      value,
					Expr:       `'yyyy'`,
					CacheIndex: 2,
					Setter: func(v string) error {
						args.Name = v
						return nil
					},
				}); err != nil {
					return nil, err
				}
				ret, err := s.resolve_Federation_User(ctx, args)
				if err != nil {
					return nil, err
				}
				return ret, nil
			},
		})
	}

	if err := def_u(ctx); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}

	// assign named parameters to message arguments to pass to the custom resolver.
	req.U = value.vars.U

	// create a message value to be returned.
	ret := &GetStatusResponse{}

	// field binding section.
	// (grpc.federation.field).by = "u"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[*User]{
		Value:      value,
		Expr:       `u`,
		CacheIndex: 3,
		Setter: func(v *User) error {
			ret.User = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}

	grpcfed.Logger(ctx).DebugContext(ctx, "resolved federation.GetStatusResponse", slog.Any("federation.GetStatusResponse", s.logvalue_Federation_GetStatusResponse(ret)))
	return ret, nil
}

// resolve_Federation_User resolve "federation.User" message.
func (s *DebugService) resolve_Federation_User(ctx context.Context, req *DebugService_Federation_UserArgument) (*User, error) {
	ctx, span := s.tracer.Start(ctx, "federation.User")
	defer span.End()
	ctx = grpcfed.WithLogger(ctx, grpcfed.Logger(ctx), grpcfed.LogAttrs(ctx)...)

	grpcfed.Logger(ctx).DebugContext(ctx, "resolve federation.User", slog.Any("message_args", s.logvalue_Federation_UserArgument(req)))
	type localValueType struct {
		*grpcfed.LocalValue
		vars struct {
		}
	}
	value := &localValueType{LocalValue: grpcfed.NewLocalValue(ctx, s.celEnvOpts, "grpc.federation.private.UserArgument", req)}

	// create a message value to be returned.
	ret := &User{}

	// field binding section.
	// (grpc.federation.field).by = "$.id"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
		Value:      value,
		Expr:       `$.id`,
		CacheIndex: 4,
		Setter: func(v string) error {
			ret.Id = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}
	// (grpc.federation.field).by = "$.name"
	if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[string]{
		Value:      value,
		Expr:       `$.name`,
		CacheIndex: 5,
		Setter: func(v string) error {
			ret.Name = v
			return nil
		},
	}); err != nil {
		grpcfed.RecordErrorToSpan(ctx, err)
		return nil, err
	}

	grpcfed.Logger(ctx).DebugContext(ctx, "resolved federation.User", slog.Any("federation.User", s.logvalue_Federation_User(ret)))
	return ret, nil
}

func (s *DebugService) logvalue_Federation_GetStatusResponse(v *GetStatusResponse) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.Any("user", s.logvalue_Federation_User(v.GetUser())),
	)
}

func (s *DebugService) logvalue_Federation_GetStatusResponseArgument(v *DebugService_Federation_GetStatusResponseArgument) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue()
}

func (s *DebugService) logvalue_Federation_User(v *User) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("id", v.GetId()),
		slog.String("name", v.GetName()),
	)
}

func (s *DebugService) logvalue_Federation_UserArgument(v *DebugService_Federation_UserArgument) slog.Value {
	if v == nil {
		return slog.GroupValue()
	}
	return slog.GroupValue(
		slog.String("id", v.Id),
		slog.String("name", v.Name),
	)
}
