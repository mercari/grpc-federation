{{- define "evalDef" -}}
{{- $def := .Definition }}
{{- if $def.IsMap -}}
{{- $mapResolver := $def.MapResolver -}}
grpcfed.EvalDefMap({{ .Ctx }}, value, grpcfed.DefMap[{{ $def.Type }}, {{ $mapResolver.IteratorSourceType }}, *localValueType]{
	{{- if $def.UseIf }}
	If: "{{ $def.If }}",
	IfUseContextLibrary: {{ $def.IfUseContextLibrary }},
	IfCacheIndex: {{ $def.CELCacheIndex }},
	{{- end }}
	Name:   "{{ $def.Key }}",
	Type:   {{ $def.CELType }},
	Setter: func(value *localValueType, v {{ $def.Type }}) { value.vars.{{ $def.Key }} = v },
	IteratorName: "{{ $mapResolver.IteratorName }}",
	IteratorType: {{ $mapResolver.IteratorCELType }},
	IteratorSource: func(value *localValueType) []{{ $mapResolver.IteratorSourceType }}{ return {{ $mapResolver.IteratorSource }} },
	Iterator: func(ctx context.Context, value *grpcfed.MapIteratorValue) (any, error) {
		{{- if $mapResolver.IsBy }}
		{{- $by := $mapResolver.MapExpr.Expr.By }}
		return grpcfed.EvalCEL(ctx, &grpcfed.EvalCELRequest{
			Value: value,
			Expr: "{{ $by.Expr }}",
			UseContextLibrary: {{ $by.UseContextLibrary }},
			OutType: reflect.TypeOf({{ $mapResolver.IteratorZeroValue }}),
			CacheIndex: {{ $def.CELCacheIndex }},
		})
		{{- else if $mapResolver.IsMessage }}
		{{- $arguments := $mapResolver.Arguments }}
		args := &{{ $mapResolver.RequestType }}{
			{{- range $arguments }}
			{{- if not .CEL }}
			{{ .Name }}: {{ .Value }}, {{ .ProtoComment }}
			{{- end }}
			{{- end }}
		}
		{{- range $arguments }}
		{{- if .CEL }}
		{{ .ProtoComment }}
		if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[{{ .Type }}]{
			Value: value,
			Expr: "{{ .CEL.Expr }}",
			UseContextLibrary: {{ .CEL.UseContextLibrary }},
			CacheIndex: {{ $def.CELCacheIndex }},
			Setter: func(v {{ .Type }}){
				{{- if ne (len .InlineFields) 0 }}
				{{- range .InlineFields }}
				args.{{ .Name }} = {{ .Value }}
				{{- end }}
				{{- else }}
				args.{{ .Name }} = {{ .Value }}
				{{- end }}
			},
		}); err != nil {
			return nil, err
		}
		{{- end }}
		{{- end }}
		return s.{{ $mapResolver.Caller }}(ctx, args)
		{{- end }}
	},
})
{{- else -}}
grpcfed.EvalDef({{ .Ctx }}, value, grpcfed.Def[{{ $def.Type }}, *localValueType]{
	{{- if $def.UseIf }}
	If: "{{ $def.If }}",
	IfUseContextLibrary: {{ $def.IfUseContextLibrary }},
	IfCacheIndex: {{ $def.CELCacheIndex }},
	{{- end }}
	Name:   "{{ $def.Key }}",
	Type:   {{ $def.CELType }},
	Setter: func(value *localValueType, v {{ $def.Type }}) { value.vars.{{ $def.Key }} = v },
	{{- if $def.IsBy }}
	By:     "{{ $def.By.Expr }}",
	ByUseContextLibrary: {{ $def.By.UseContextLibrary }},
	ByCacheIndex: {{ $def.CELCacheIndex }},
	{{- else if $def.IsValidation }}
	Validation:  func(ctx context.Context, value *localValueType) error {
		{{- template "messageValidation" (map "Ctx" .Ctx "Error" $def.ValidationError) }}
	},
	{{- else }}
	Message: func(ctx context.Context, value *localValueType) (any, error) {
		{{- $arguments := $def.Arguments }}
		{{- if $def.UseArgs }}
		args := &{{ $def.RequestType }}{
			{{- range $arguments }}
			{{- if not .CEL }}
			{{ .Name }}: {{ .Value }}, {{ .ProtoComment }}
			{{- end }}
			{{- end }}
		}
		{{- end }}
		{{- range $arguments }}
		{{- if .CEL }}
		{{ .ProtoComment }}
		if err := grpcfed.SetCELValue(ctx, &grpcfed.SetCELValueParam[{{ .Type }}]{
			Value: value,
			Expr: "{{ .CEL.Expr }}",
			UseContextLibrary: {{ .CEL.UseContextLibrary }},
			CacheIndex: {{ $def.CELCacheIndex }},
			Setter: func(v {{ .Type }}){
				{{- if ne (len .InlineFields) 0 }}
				{{- range .InlineFields }}
				args.{{ .Name }} = {{ .Value }}
				{{- end }}
				{{- else }}
				args.{{ .Name }} = {{ .Value }}
				{{- end }}
			},
		}); err != nil {
			return nil, err
		}
		{{- end }}
		{{- end }}
		{{- if $def.IsCall }}
		s.logger.DebugContext(ctx, "call {{ $def.MethodFQDN }}", slog.Any("{{ $def.RequestTypeFQDN }}", s.logvalue_{{ $def.LogValueRequestType }}(args)))
		{{- end }}
		{{- if $def.UseTimeout }}
		return grpcfed.WithTimeout[{{ $def.ReturnType }}](ctx, "{{ $def.MethodFQDN }}", {{ $def.Timeout }}, func(ctx context.Context) (*{{ $def.ReturnType }}, error) {
			{{- if $def.UseRetry }}
			{{- template "retry" (map "Retry" $def.Retry) }}
			return grpcfed.WithRetry(ctx, &grpcfed.RetryParam[{{ $def.ReturnType }}]{
				Value: value,
				If: "{{ $def.Retry.If.Expr }}",
				UseContextLibrary: {{ $def.Retry.If.UseContextLibrary }},
				CacheIndex: {{ $def.CELCacheIndex }},
				BackOff: b,
				Body: func() (*{{ $def.ReturnType }}, error) {
					return s.{{ $def.Caller }}(ctx, args)
				},
			})
			{{- else }}
			return s.{{ $def.Caller }}(ctx, args)
			{{- end }}
		})
		{{- else if $def.UseRetry }}
		{{- template "retry" (map "Retry" $def.Retry) }}
		return grpcfed.WithRetry(ctx, &grpcfed.RetryParam[{{ $def.ReturnType }}]{
			Value: value,
			If: "{{ $def.Retry.If.Expr }}",
			UseContextLibrary: {{ $def.Retry.If.UseContextLibrary }},
			CacheIndex: {{ $def.CELCacheIndex }},
			BackOff: b,
			Body: func() (*{{ $def.ReturnType }}, error) {
				return s.{{ $def.Caller }}(ctx, args)
			},
		})
		{{- else }}
		return s.{{ $def.Caller }}(ctx, args)
		{{- end }}
	},
	{{- end }}
})
{{- end }}
{{- end }}

{{- define "evalMessageDef" }}
// This section's codes are generated by the following proto definition.
/*
{{ .Definition.ProtoComment }}
*/
if err := {{- template "evalDef" (map "Ctx" .Ctx "Definition" .Definition) -}}; err != nil {
	{{- template "errorHandler" (map "Ctx" .Ctx "Definition" .Definition) }}
}
{{- end }}

{{- define "evalDefGroup" }}
{{- if .Definition.IsConcurrent }}
eg, {{ printf "ctx%d" .Level }} := grpcfed.ErrorGroupWithContext({{ parentCtx .Level }})
{{- range .Definition.Starts }}
grpcfed.GoWithRecover(eg, func() (any, error) {
	{{- template "evalDefGroup" (map "Level" (add $.Level 1) "Definition" .) }}
	return nil, nil
})
{{- end }}
if err := eg.Wait(); err != nil {
	return nil, err
}
{{- if .Definition.ExistsEnd }}
{{ template "evalMessageDef" (map "Ctx" (parentCtx .Level) "Definition" .Definition.End) }}
{{- end }}

{{- else }}

{{- if .Definition.ExistsStart }}
{{ template "evalDefGroup" (map "Level" .Level "Definition" .Definition.Start) }}
{{- end }}

{{- if .Definition.ExistsEnd }}
{{ template "evalMessageDef" (map "Ctx" (parentCtx .Level) "Definition" .Definition.End) }}
{{- end }}

{{- end }}
{{- end }}

{{- define "evalDefSet" -}}

{{- $depGraph := .DependencyGraph }}
{{- if $depGraph }}
// A tree view of message dependencies is shown below.
/*
{{ $depGraph }}*/
{{- end }}
{{- $defGroups := .VariableDefinitionGroups }}
{{- $defGroupsLen := len $defGroups }}
{{- if eq $defGroupsLen 1 }}
{{- template "evalDefGroup" (map "Level" 1 "Definition" (index $defGroups 0)) }}
{{- else }}
{{- if $defGroups }}
eg, ctx1 := grpcfed.ErrorGroupWithContext(ctx)
{{- end }}
{{ range $defGroups }}
grpcfed.GoWithRecover(eg, func() (any, error) {
	{{- template "evalDefGroup" (map "Level" 2 "Definition" .) }}
	return nil, nil
})
{{ end }}
{{- if $defGroups }}
if err := eg.Wait(); err != nil {
	return nil, err
}
{{- end }}
{{- end }}

{{- end }}
